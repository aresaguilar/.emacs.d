#+TITLE: Ares' Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: overview

* Configuration
  :PROPERTIES:
  :VISIBILITY: children
  :END:
** About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>

This is my personal configuration in a literate programming style.
This file gets tangled with the command =M-x org-babel-tangle= (=C-c C-v t=).

** Prerequisites

Following packages must be installed in your emacs (or will be installed
automatically):

#+NAME: required-packages
    - ace-window
    - avy
    - auto-complete
    - clipmon
    - company
    - ecb
    - ess
    - ess-R-data-view
    - expand-region
    - fill-column-indicator
    - helm
    - helm-projectile
    - json-mode
    - key-chord
    - magit
    - monky
    - monokai-theme
    - multiple-cursors
    - org-pomodoro
    - persistent-scratch
    - projectile
    - smart-mode-line
    - undo-tree
    - use-package
    - yasnippet
    - company-quickhelp
    - helm-company
If you don't like any of these, just use the tag =:disabled t=
in =use-package=.

** Starting up

Everything that should be loaded at startup is here.
Changes to env variables should be done here.

#+BEGIN_SRC emacs-lisp :tangle yes
  (package-initialize)

  ;; Disable some messages
  (setq package-enable-at-startup nil)
  (setq ad-redefinition-action 'accept)
  (setq ad-redefinition-action 'accept)

  ;; Set custom file
  (setq custom-file "~/.emacs.d/custom-settings.el")
  (load custom-file t)

  ;; Add Melpa repo if not present
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
    (package-refresh-contents)
  )

  ;; Always try to install a package if not present
  (setq use-package-always-ensure t)
#+END_SRC

** Personal information

My name, email and other personal information.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Ares Aguilar"
      user-mail-address "aresaguilarsotos@gmail.com")
#+END_SRC

** General configuration
*** Backups

By default, Emacs saves backup files in the same directory as the file.
The following code stashes them all in =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Same with auto backup files.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

*** History

This section is about session persistence. It saves the following:
 - Minibuffer
 - Kill Ring
 - Search Ring
 - Regexp Search Ring
 - Scratch buffer

I use =savehist= package to save all history in =~/.emacs.d/savehist=

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package savehist
    :config
    (progn
      (setq savehist-file "~/.emacs.d/savehist"
            history-length t
            history-delete-duplicates t
            savehist-save-minibuffer-history 1
            savehist-additional-variables
            '(kill-ring
              search-ring
              regexp-search-ring))
      (savehist-mode 1)))
#+END_SRC

To save the scratch buffer contents, I use =persistent-scratch=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default))
#+END_SRC

*** Helm

=Helm= is an incremental completion and selection narrowing framework for Emacs.
Instead of autocompleting, narrows all possibilities by regexes.
I replace the following emacs commands with helm equivalents:
    - =M-x=
    - =C-x C-f=
    - =M-y=
    - =C-h a=
    - =C-x C-b=
    - =C-x c o=
    - =C-x r m=

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helm
      :diminish helm-mode
      :init
      (progn
        (require 'helm-config)
        (require 'helm)
        (global-set-key (kbd "C-c h") 'helm-command-prefix)
        (global-unset-key (kbd "C-x c"))
        (setq helm-candidate-number-limit 100
              helm-idle-delay 0.0
              helm-input-idle-delay 0.01
              helm-yas-display-key-on-candidate t
              helm-quick-update t
              helm-M-x-requires-pattern nil
              helm-ff-skip-boring-files t
              helm-split-window-in-side-p t
              helm-display-header-line nil
              helm-autoresize-max-height 30
              helm-autoresize-min-height 30)
        (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
        (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
        (define-key helm-map (kbd "C-z")  'helm-select-action)
        (set-face-attribute 'helm-source-header nil :height 0.1)
        (helm-mode))
      :bind (("C-x b" . helm-mini)
             ("C-h a" . helm-apropos)
             ("C-x C-b" . helm-buffers-list)
             ("M-y" . helm-show-kill-ring)
             ("M-x" . helm-M-x)
             ("C-x c o" . helm-occur)
             ("C-x C-f" . helm-find-files)
             ("C-x r m" . helm-filtered-bookmarks)))
#+END_SRC

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Undo tree mode

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made,
undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package guide-key
  :defer t
  :diminish guide-key-mode
  :config
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

** Interface customization
*** Frames

I like to have as much screen space as possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(tool-bar-mode -1)
(menu-bar-mode -1)
#+END_SRC

*** Windows

I don't like scrollbars.

#+BEGIN_SRC emacs-lisp :tangle yes
(scroll-bar-mode -1)
#+END_SRC

*** Theme

Best theme in Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package monokai-theme
    :config
    (load-theme 'monokai t))
#+END_SRC

*** Modeline

Display a more compact (and prezi) mode line.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smart-mode-line
    :config
    (sml/setup))
#+END_SRC

** Editing text
*** Encoding

I always use UTF-8, so lets let Emacs know.

#+BEGIN_SRC emacs-lisp :tangle yes
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq buffer-file-coding-system 'utf-8)
(setq default-file-name-coding-system 'utf-8)
(setq default-keyboard-coding-system 'utf-8)
(setq default-process-coding-system '(utf-8 . utf-8))
(setq default-sendmail-coding-system 'utf-8)
(setq default-terminal-coding-system 'utf-8)
(set-language-environment "UTF-8")
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Whitespace mode

I like to see special chars, specially trailing whitespaces.
Fortunately, there's a mode for that.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package whitespace
    :config
    (progn
      (setq whitespace-display-mappings
            ;; all numbers are Unicode codepoint in decimal. try (insert-char 182 ) to see it
            '(
              (space-mark 32 [183] [46]) ; 32 SPACE, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
              (newline-mark 10 [182 10]) ; 10 LINE FEED
              (tab-mark 9 [9655 9] [92 9]) ; 9 TAB, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」
              ))
      (set-face-attribute 'whitespace-space nil :foreground "#272822")))
#+END_SRC

*** Zapping

=zap-to-char= kills the region between the point and the next occurence
of the character you type. I prefer using =avy-zap= instead of the
default version, so I have it on the same keybinding, =M-z=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package avy-zap
    :bind (("M-z" . avy-zap-up-to-char-dwim)
           ("M-Z" . avy-zap-to-char-dwim)))
#+END_SRC

*** Copying (aka Save to Kill Ring)

=M-w= saves a current line to kill ring (aka copies) if no region is
selected.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun slick-copy (beg end)
  (interactive
   (if mark-active
       (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position) (line-beginning-position 2)))))

(advice-add 'kill-ring-save :before #'slick-copy)
#+END_SRC

*** Expand region

This is something I have to get the hang of too.
It gradually expands the selection, and it's bound to =C-+=

#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :defer t
    :bind ("C-+" . er/expand-region))
#+end_src

*** Multiple cursors

Sublime-like editing with multiple cursors.
To activate it, mark lines and hit =CC=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

** Navigation
*** Scrolling

Emacs default scrolling sucks. Fortunately, it is very easy to fix.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ; one line at a time
        mouse-wheel-progressive-speed nil            ; don't accelerate
        mouse-wheel-follow-mouse 't                  ; scroll window under mouse
        scroll-conservatively 10000
        auto-window-vscroll nil
   )
#+END_SRC

*** Ace Window

[[https://github.com/abo-abo/ace-window][ace-window]] let's you move between open windows using a key press after
the command. I have it bound to a [[Key%20chords][key-chord]], =jw=.

When in =ace-window= mode, you can change the action with a modifier key:

| =x= | delete window                         |
| =m= | swap (move) window                    |
| =v= | split window vertically               |
| =b= | split window horizontally             |
| =n= | select the previous window            |
| =i= | maximize window (select which window) |
| =o= | maximize current window               |

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

*** Avy

[[https://github.com/abo-abo/avy][Avy]] makes jumping to char, word and line very easy.
At this point, I can't remember more keybindings, so I will bind them
to some [[Key%20chords][key-chords]] later and override the default =goto-line= one, =M-g g=.

The only one I am defining (besides those above) is =C-'= in =isearch-mode-map=.

#+BEGIN_SRC emacs-lisp :tangle yes
      (use-package avy
        :bind ("M-g g" . avy-goto-line)
        :config (define-key isearch-mode-map (kbd "C-'") 'avy-isearch))
#+END_SRC

*** Switch buffer

This acts like =Alt-<tab>= for buffers.
Took it from [[http://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/][here]].
And it's bound to a keychord, =JJ=.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC

*** Key chords

A key-chord is a combination of keys pressed without modifiers.
I use the following:

| uu | undo                     |
| JJ | previous buffer          |
| jj | avy-goto-char-timer      |
| jk | avy-goto-char            |
| jw | ace-window               |
| jl | avy-goto-word-or-subword |
| CC | multiple cursors         |
| gg | avy-goto-line            |

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package key-chord
    :init
    (progn
      (setq key-chord-one-key-delay 0.15)
      (key-chord-mode 1)
      (key-chord-define-global "uu" 'undo)
      (key-chord-define-global "JJ" 'switch-to-previous-buffer)
      (key-chord-define-global "jj" 'avy-goto-char-timer)
      (key-chord-define-global "jk" 'avy-goto-char)
      (key-chord-define-global "jl" 'avy-goto-word-or-subword-1)
      (key-chord-define-global "jw" 'ace-window)
      (key-chord-define-global "gg" 'avy-goto-line)
      (key-chord-define-global "CC" 'mc/edit-lines)))
#+END_SRC

*** Bookmarks

Bookmarks are a really nice feature of emacs. It lets you save the
current point position (no matter if in a file, directory or remote)
for latter access.

I use helm-bookmark instead of the default to create and jump to
bookmarks with a single comand, =C-x r m=. As I have a lot of bookmarks
for directories, I want to find-files there instead of opening a dired
buffer when jumping to the bookmark.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bookmark
    :defer t
    :config (progn
              (defun bookmark-find-from-dir-or-default (orig-fun bmk-record)
                "Around Advice for bookmark-default-handler.  Calls
               through unless bookmark is a directory, in which
               case, calls helm-find-file."
                (let ((file (bookmark-get-filename bmk-record)))
                  (if (file-directory-p file)
                      (let ((default-directory file))
                        (call-interactively 'helm-find-files))
                    (funcall orig-fun bmk-record))))
              (advice-add `bookmark-default-handler
                          :around #'bookmark-find-from-dir-or-default)))
#+END_SRC

*** Move to beginning of line
Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

** File management

I use dired as my file manager, but its interface is very cluttered.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
(setq-default dired-omit-files-p t)
(setq diredp-hide-details-initially-flag t)
(setq diredp-hide-details-propagate-flag t)
#+END_SRC

And I like to go up one level using =^=

#+BEGIN_SRC emacs-lisp :tangle yes
(define-key key-translation-map [dead-circumflex] "^")
#+END_SRC

** Web Browser

I know emacs has eww, but I love w3m.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq browse-url-browser-function 'w3m-browse-url)
#+END_SRC

** ORG mode

I use [[http://www.orgmode.org][Org Mode]] to take notes, record my life, save
my recipes, write this file and all sort of stuff.

*** My files
    :PROPERTIES:
    :CUSTOM_ID: org-files
    :END:

#<<org-files>>

Here are the Org files I use.

| ARES.org    | Main ORG file. Here I have my notes, tasks, finances and other stuff. |
| cocina.org  | Recipes and shopping list.                                            |
| magia.org   | Magic tricks and ideas.                                               |
| notas.org   | Unclassified notes.                                                   |
| trabajo.org | Work-related stuff.                                                   |

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-directory "~/ORG")
#+END_SRC

*** General configuration

Let's start with some general configuration:
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'auto-complete-config)
  ;; Make auto-complete work in org
  (add-to-list 'ac-modes 'org-mode)
  ;; Variables
  (custom-set-variables
   ;; Agenda files
   '(org-agenda-files (quote ("~/ORG/ARES.org" "~/ORG/trabajo.org")))
   ;; Number of consecutive days in agenda
   '(org-agenda-ndays 7)
   ;; Number of days to warn for deadlines
   '(org-deadline-warning-days 5)
   ;; Show all days in agenda, even without tasks
   '(org-agenda-show-all-dates t)
   ;; Don't warn deadlines if done
   '(org-agenda-skip-deadline-if-done t)
   ;; Don't show scheduled if done
   '(org-agenda-skip-scheduled-if-done t)
   ;; Show newest notes at top
   '(org-reverse-note-order t)
   ;; Allow using tab to indent in code blocks
   '(org-src-tab-acts-natively t)
   ;; <RET> follows links
   '(org-return-follows-link t))
#+END_SRC

I like to have my main ORG file handy, so I have a shortcut that opens
it, bound to =C-c a=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c a")
                  (lambda () (interactive) (find-file "~/ORG/ARES.org")))
#+END_SRC

I use ORG refile to quickly jump to a heading (=C-u C-c C-w=) and to
move trees around my org-agenda-files (=C-c C-w=).

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
#+END_SRC

*** ORG Capture

I use [[http://orgmode.org/manual/Capture.html][ORG capture]] to quickly take notes from wherever I am. I have it
bound to a keybinding, =C-c c=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-default-notes-file "~/ORG/notas.org")
  (setq org-capture-templates
        '(("a" "ARES Task" entry (file+headline "ARES.org" "TAREAS")
           "** TODO %?\n   %i\n"
           :empty-lines 1 :clock-keep t :kill-buffer t :prepend t)
          ("w" "WORK Task" entry (file+headline "trabajo.org" "TAREAS")
           "** TODO %?\n   %i\n"
           :empty-lines 1 :clock-keep t :kill-buffer t :prepend t)
          ("t" "TICKET" entry (file+headline "trabajo.org" "TICKETS")
           "** TODO [[https://10.0.1.151:3001/issues/%c][%^{Descripcion}]]\n   DEADLINE: %^t\n   :PROPERTIES:\n   :TICKET:   %c\n   :END:\n%^{BRANCH}p"
           :empty-lines 1 :clock-keep t :kill-buffer t :immediate-finish t :prepend t)
          ("p" "Required Package" item (file+headline "~/.emacs.d/init.org" "Prerequisites")
           "%i%?\n"
           :clock-keep t :kill-buffer t)
          ))
#+END_SRC

*** Pomodoro

I'm starting to use the [[pomodorotechnique.com][Pomodoro Technique]] to stay focused and be more
productive at work. To start a pomodoro, move point to a task and call
=org-pomodoro=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-pomodoro
    :config
    (setq org-pomodoro-length 20))
#+END_SRC

*** Cook mode

Template for saving my recipes.

#+BEGIN_SRC emacs-lisp :tangle yes
;; source: http://lebensverrueckt.haktar.org/articles/org-mode-Food/
(defun food/gen-shopping-list ()
  "Generate shopping list from COCINAR items."
  (interactive)
  (goto-line 0)
  (let ((start-shopping-list (search-forward "* COMPRA" nil t)))
    (while (search-forward "** COCINAR" nil t)
      (show-subtree)
      (outline-next-visible-heading 1)
      (next-line)
      (let ((start (point)))
        (outline-next-visible-heading 1)
        ;;(previous-line)
        (copy-region-as-kill start (point)))
      (save-excursion
        (goto-char start-shopping-list)
        (newline)
        (yank)
        (show-subtree)
        (delete-blank-lines)))
    (goto-char start-shopping-list)
    (next-line)
    (org-table-goto-column 2)
    (org-table-sort-lines nil ?a)
    (goto-char start-shopping-list)
    (org-mark-subtree)
    (next-line)
    (flush-blank-lines))
  (org-table-align)
  (previous-line)
  (org-shifttab))
(defun food/clear-shopping-list ()
  "Clear everything in the shopping list."
  (interactive)
  (save-excursion
    (goto-line 0)
    (let ((start-shopping-list (search-forward "* COMPRA" nil t)))
      (show-subtree)
      (outline-next-visible-heading 1)
      (previous-line)
      (end-of-line)
      (kill-region start-shopping-list (point)))))
;; RECIPE template
(defun recipe-template ()
  "Create new recipe and add it to RECIPES list."
  (interactive)
  (goto-line 0)
  (search-forward "* RECETAS")
  (org-meta-return)
  (org-metaright)
  (setq recipe-name (read-string "Nombre: "))
  (insert recipe-name)
  (org-set-tags)
  (org-meta-return)
  (org-metaright)
  (insert "Ingredientes")
  (org-meta-return)
  (insert "Preparación")
  (search-backward recipe-name)
  (setq source (read-string "Fuente: "))
  (org-set-property "Fuente" source)
  (setq amount (read-string "Cantidad: "))
  (org-set-property "Cantidad" amount)
  )
#+END_SRC

*** Work mode

Another template, this time for saving a ticket.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun ticket-template ()
  "Create new ticket and add it to TICKETS list."
  (interactive)
  (goto-line 0)
  (search-forward "* TICKETS")
  (setq ticket-number (read-string "Ticket (num): "))
  (save-excursion
    (goto-line 0)
    (unless (eq (how-many (concat ":TICKET:[[:blank:]]+" ticket-number)) 0)
      (setq ticket-number (read-string "YA EXISTE. Otro?: "))
      ))
  (org-meta-return)
  (org-metaright)
  (setq ticket-name (read-string "Ticket (desc): "))
  (insert (concat
           "[[https://10.0.1.151:3001/issues/"
           ticket-number
           "]["
           ticket-name
           "]]"))
  (org-shiftright)
  (org-set-property "TICKET" ticket-number)
  (org-set-property "DEADLINE" "123")
  (org-set-tags)
  )
#+END_SRC

** Coding
*** General

I don't like tabs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

I don't like to type closing parens.

#+BEGIN_SRC emacs-lisp :tangle yes
  (electric-pair-mode 1)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
#+END_SRC

But I do love to know where I am.

#+BEGIN_SRC emacs-lisp :tangle yes
  (column-number-mode 1)
  (set-fill-column 80)
#+END_SRC

Let's make clear where that 80 column is, in the global way.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package fill-column-indicator
    :config
    (define-globalized-minor-mode my-global-fci-mode fci-mode turn-on-fci-mode)
    (my-global-fci-mode 1))
#+END_SRC

*** VCS
**** Magit

I'm learning Magit. There's a very good starters tutorial [[https://github.com/jkitchin/magit-tutorial][here]].
Currently, I'm using =C-x g= to run the command =magit-status=,
and =s= to stage, =c c= to commit and =P p= to push. Sometimes
I have to use =l l= to see the short log.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :bind ("C-c g" . magit-status))
#+END_SRC

**** Monky

Monky is like Magit for HG. I use =monky-status= with the keybinding
=C-x G=

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package monky
    :bind ("C-c G" . monky-status))
#+END_SRC

*** CTAGS

Etags allow to visit a symbol's definition using =M-.=
Tags must be created first, using the following function.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq path-to-ctags "ctags")
(defun create-tags (dir-name)
  "Create tags file"
  (interactive "DDirectory: ")
  (shell-command
   (format "%s -f TAGS -e -R %s" path-to-ctags (directory-file-name dir-name))))
#+END_SRC

*** Projectile

Projectile configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :diminish projectile-mode
    :config
    (progn
      (setq projectile-keymap-prefix (kbd "C-c p")
            projectile-completion-system 'default
            projectile-enable-caching t
            projectile-indexing-method 'alien
            projectile-switch-project-action 'helm-projectile)
      (add-to-list 'projectile-globally-ignored-files "node-modules"))
    :config
    (projectile-global-mode))
  ;; Use projectile with helm
  (use-package helm-projectile)
#+END_SRC

*** ECB

ECB stands for Emacs Code Browser.

**** General configuration

General ECB configuration: disable tips, maximize at startup...

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'ecb)
(require 'ecb-util)
(require 'ecb-layout)
(require 'ecb-common-browser)
(eval-when-compile
  ;; to avoid compiler grips
  (require 'cl))

(setq ecb-tip-of-the-day nil)

;; Resize window with ECB
(add-hook 'ecb-deactivate-hook 'toggle-frame-maximized t)
;; resize the ECB window to be default (order matters here)
(add-hook 'ecb-activate-hook (lambda () (ecb-redraw-layout)))
(add-hook 'ecb-activate-hook 'toggle-frame-maximized t)
#+END_SRC

**** Layout definitions
***** FONETIC layout

Layout for my FONETIC workflow. It consists of three left windows
(directories, files and methods) and one TODO window at the right.

****** Todo buffer

A buffer showing the contents of =c:/Users/aaguilar/ORG/trabajo.org=

#+BEGIN_SRC emacs-lisp :tangle yes
(defconst ecb-todo-buffer-name " *ECB todo")
(defun ecb-goto-todo-window ()
  "Make the todo window the current window."
  (interactive)
  (ecb-goto-ecb-window ecb-todo-buffer-name))
(defun ecb-todo-buffer-create ()
  "Create the todo buffer."
  (save-excursion
    (if (get-buffer ecb-todo-buffer-name)
        (get-buffer ecb-todo-buffer-name)
      (progn
        (find-file "c:/Users/aaguilar/ORG/trabajo.org")
        (get-buffer (rename-buffer ecb-todo-buffer-name))))))
(defecb-window-dedicator-to-ecb-buffer ecb-set-todo-buffer
    ecb-todo-buffer-name nil
  "Set the buffer in the current window to the todo-buffer and make this
window dedicated for this buffer."
  (switch-to-buffer (buffer-name (ecb-todo-buffer-create))))
#+END_SRC

****** Layout definition
#+BEGIN_SRC emacs-lisp :tangle yes
(ecb-layout-define "FONETIC-layout" left-right
  "ECB Layout for FONETIC-IVR_VDF Workflow."
  ;; 1. Define directories buffer
  (ecb-set-directories-buffer)
  ;; 2. Splitting the left column in two windows
  (ecb-split-ver 0.34)
  ;; 3. Define sources buffer
  (ecb-set-sources-buffer)
  ;; 4. Split again and switch
  (ecb-split-ver 0.5)
  ;; 5. Define methods buffer
  (ecb-set-methods-buffer)
  (select-window (next-window (next-window)))
  ;; 6. Define TODO buffer
  (ecb-set-todo-buffer)
  ;; 7. Go back to ECB Edit window
  (select-window (previous-window (selected-window) 0))
  )
#+END_SRC

*** Snippets

Yasnippet is a snippet framework for Emacs.
Snippets are stored at =~/.emacs.d/snippets=

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC

*** Autocompletion

I use company-mode for completion.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :config (progn
              (setq company-idle-delay 0.5)
              (setq company-minimum-prefix-length 2)
              (global-company-mode 1)))
#+END_SRC

But I loved the way auto-complete displayed the documentation in a
pop-up. Fortunately, we have company-help to do the same thing, that
can be triggered from company with the keybinding =M-h=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-quickhelp
    :config (progn
              (eval-after-load 'company
                '(define-key company-active-map
                   (kbd "M-h")
                   #'company-quickhelp-manual-begin))
              (company-quickhelp-mode 1)))
#+END_SRC

Finally, I love Helm (you may have noticed that). So let's bound
=helm-company= to =C-:= when in company-mode just in case we need some
good old narrowing.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-company
    :config (eval-after-load 'company
              '(progn
                 (define-key company-mode-map (kbd "C-:") 'helm-company)
                 (define-key company-active-map (kbd "C-:") 'helm-company))))
#+END_SRC

*** Emacs Lisp

**** Eldoc

Eldoc provides minibuffer hints when working with Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package "eldoc"
  :diminish eldoc-mode
  :commands turn-on-eldoc-mode
  :defer t
  :init
  (progn
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
#+END_SRC

*** C

Code style.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cc-mode)
  (setq-default c-basic-offset 4 c-default-style "k&r")
  (define-key c-mode-base-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** R

ESS (Emacs Speaks Statistics) is a package that provides functions
for many statistical languages. I only use the R part.

I also like to see what a variable holds. I use =C-c v= for that.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; ESS Package
  (use-package ess-site
    :ensure ess
    :commands R
    :config
    (use-package ess-R-data-view
      :config
      (define-key ess-mode-map (kbd "C-c v") 'ess-R-dv-ctable)))
  ; Open *.r in R-mode
  (add-to-list 'auto-mode-alist '("\\.r\\'" . R-mode))
  ; Expand methods window in ECB at start
  (add-to-list 'ecb-non-semantic-methods-initial-expand 'R-mode)
  ; Make ECB default layout left3
  (add-hook 'R-mode-hook (lambda ()
                           (setq ecb-layout-name "left3")))
#+END_SRC

*** LaTeX

Configuration related to LaTeX

#+BEGIN_SRC emacs-lisp :tangle yes
;; Force LaTeX mode for .tex files
(add-to-list 'auto-mode-alist '("\\.tex\\'" . TeX-mode))

;; RefTeX loading
(add-hook 'TeX-mode-hook 'turn-on-reftex) ; Activar reftex con AucTeX
(setq reftex-plug-into-AUCTeX t)            ; Conectar a AUC TeX con RefTeX
(setq TeX-default-mode '"latex-mode")       ; Modo ordinario para ficheros .tex
(setq TeX-force-default-mode t)             ; Activar siempre dicho modo.

;; TeX settings
(setq TeX-parse-self t)                     ; Preview on load
(setq TeX-auto-save t)                      ; Auto Save
(setq TeX-PDF-mode t)                       ; PDF instead of div
(add-hook 'TeX-mode-hook 'flyspell-mode)    ; Enable spell-checking
(add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode)
(add-hook 'TeX-mode-hook
          (lambda () (TeX-fold-mode 1)))    ; Automatically activate TeX-fold-mode.
(add-hook 'TeX-mode-hook 'LaTeX-math-mode)
#+END_SRC

And autocompletion.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-auctex
    :defer t
    :config (company-auctex-init))
#+END_SRC

*** VXML

VoiceXML isn't supported in emacs, so I will expand =nxml-mode= with
proper syntax.

First, lets add =<form>= ids to the imenu bar and set up ECB layout.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'ecb-non-semantic-methods-initial-expand 'nxml-mode)
  (add-hook 'nxml-mode-hook
            (lambda ()
              (set-variable
               'imenu-generic-expression
               (list
                (list
                 nil
                 "\\(<form id=\"\\)\\([A-Za-z0-9_]+\.\\)?\\([A-Za-z0-9\._]+\\)\\(\">\\)" 3)))
              (imenu-add-to-menubar "XML")
              (setq ecb-layout-name "FONETIC-layout")
              (add-to-list 'rng-schema-locating-files
                           "~/.emacs.d/nxml-schemas/schemas.xml")
              
              (setq nxml-child-indent 4)
              (setq nxml-attribute-indent 4)
              (setq nxml-auto-insert-xml-declaration-flag nil)
              (setq nxml-bind-meta-tab-to-complete-flag t)
              (setq nxml-slash-auto-complete-flag t)))
#+END_SRC

Then we set up the schema files and hideshow mode. This way I can hide
elements with =C-c h=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hideshow
    :config
    (add-to-list 'hs-special-modes-alist
                 '(nxml-mode
                   "<!--\\|<[^/>]*[^/]>"
                   "-->\\|</[^/>]*[^/]>"
                   "<!--"
                   sgml-skip-tag-forward
                   nil)))
  (add-hook 'nxml-mode-hook 'hs-minor-mode)
#+END_SRC

A VXML project has lots of uninteresting files (audios, grammars, etc.),
so lets make sure =projectile= and =grep= ignore them.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq projectile-globally-ignored-directories
      (append '(
                ".settings"
                "grammars"
                "grammars-gsl"
                "prompts"
                )
              projectile-globally-ignored-directories))
(setq projectile-globally-ignored-files
      (append '(
                ".project"
                "*.properties"
                "*.grxml"
                "*.grammar"
                "*.wav"
                )
              projectile-globally-ignored-files))
;; Ignore trash in grep
(setq grep-find-ignored-directories
      (append '(
                ".settings"
                "grammars"
                "grammars-gsl"
                "prompts"
                )
              grep-find-ignored-directories))
(setq grep-find-ignored-files
      (append '(
                ".project"
                "*.properties"
                "*.grxml"
                "*.grammar"
                "*.wav"
                "*.aspx"
                )
              grep-find-ignored-files))
#+END_SRC

*** Logs

At work, I have to constantly check logs. In this section I have
various configurations to work with them.

First things first, let's define an ECB layout with a dedicated
window to parse JSON:

#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; VENTANA JSON
  (defconst ecb-json-buffer-name " *ECB json")
  (defun fonlog-parse-log-tx-result ()
    "Parsea una región con el resultado de una transacción en JSON."
    (interactive)
    (save-mark-and-excursion
     (setq inhibit-read-only t)
     (unless (use-region-p)
       (move-beginning-of-line nil)
       (search-forward "{\"result\":")
       (set-mark-command nil)
       (move-end-of-line nil)
       (backward-char))
      (let ((begin (region-beginning))
            (end (region-end))
            (jbuf (get-buffer-create ecb-json-buffer-name)))
        (copy-to-buffer jbuf begin end)
        (set-buffer jbuf)
        (json-mode-beautify)
        (font-lock-fontify-buffer))
      (setq inhibit-read-only nil)))
  (defecb-window-dedicator-to-ecb-buffer ecb-set-json-buffer
      ecb-json-buffer-name nil
    "Hace del buffer actual el buffer json y lo dedica a su ventana."
    (switch-to-buffer (get-buffer-create ecb-json-buffer-name))
    (json-mode)
    (setq buffer-read-only t))
  (ecb-layout-define "FONETIC-log-layout" left
    "ECB Layout para el modo FONETIC-log."
    ;; 1. Buffer de métodos
    (ecb-set-methods-buffer)
    ;; 2. Divido la barra izquierda en dos
    (ecb-split-ver 0.7)
    ;; 3. Buffer de json
    (ecb-set-json-buffer)
    ;; 4. Voy a la ventana de edición
    (select-window (next-window)))
#+END_SRC

Then we define a syntax for the log files in order to show the important
lines in the ecb-methods window with imenu.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar fonlog-imenu-expressions
    '(
      ("GOTO" "\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)\\(goto :#\\)\\(.*\\)" 3)
      ("TX" "\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)\\(subdialog_start :request:\\)\\(http://[0-9.:]+/.*?/\\)\\(.*?\\)\\(|.*\\)" 4)
      )
    "Expresiones regulares para el imenu de log.")
  (defun fonlog-imenu-config ()
    "Realiza la configuración inicial de imenu para el modo fonlog."
    (setq-local imenu-generic-expression fonlog-imenu-expressions)
    (imenu-add-menubar-index))
  (defun fonlog-imenu-rescan ()
    "Parsea el archivo actual y actualiza imenu y el buffer de métodos de ECB."
    (interactive)
    (save-excursion
      (ecb-select-edit-window)
      (imenu--menubar-select imenu--rescan-item)
      (ecb-rebuild-methods-buffer)))
#+END_SRC

Next, lets define the syntax and faces for the font-lock highlighting.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Paleta de colores
  (defface fonlog-input-end-face
    '((t (:background "green" :foreground "black")))
    "Face para input_end MATCHED."
    :group 'fonlog)
  (defface fonlog-subdialog-face
    '((t (:background "pink" :foreground "midnight blue")))
    "Face para subdialogs."
    :group 'fonlog)
  (defface fonlog-codifis-face
    '((t (:background "purple" :foreground "yellow")))
    "Face para CODIFICACIONES."
    :group 'fonlog)
  (defface fonlog-log-face
    '((t (:background "light slate gray" :foreground "lemon chiffon")))
    "Face para log."
    :group 'fonlog)
  (defface fonlog-fetch-error-face
    '((t (:background "red" :foreground "cyan")))
    "Face para Fetch error."
    :group 'fonlog)

  (defun fonlog-font-lock-config ()
    "Realiza la configuración inicial de font-lock (subrayado) del modo fonlog."
    (set (make-local-variable 'font-lock-defaults)
                '((
                  ("\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)input_end MATCHED.*" . 'fonlog-input-end-face)
                  ("\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)subdialog_return.*" . 'fonlog-subdialog-face)
                  ("\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)log CODIFIS:.*" . 'fonlog-codifis-face)
                  ("\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Int [0-9][0-9][0-9][0-9][0-9] [0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{8\\} [0-9]+ \\)log .*" . 'fonlog-log-face)
                  ("\\(^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\.[0-9][0-9][0-9] Std [0-9][0-9][0-9][0-9][0-9] EROR\\).*" . 'fonlog-fetch-error-face)
                  )   ; Configuración de highlight
                  t)  ; No subrayar strings y comentarios
    ))
#+END_SRC

Also lets make some changes to the log buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun fonlog-config-log-buffer ()
    "Configura el buffer de log para el modo fonlog."
    ;; Optimización de lectura
    (setq-local buffer-read-only t)                     ; Modo lectura
    (setq-local make-backup-files nil)                  ; Sin backup files
    (setq-local backup-inhibited t)                     ; Inhabilita el backup

    ;; Deshabilitar autoguardado
    (auto-save-mode -1)

    ;; Configuracion autorevert
    (setq-local auto-revert-interval 2.0)
    ;(auto-revert-set-timer)
    (setq-local auto-revert-remote-files t)
    (setq-local buffer-stale-function
                #'(lambda (&optional noconfirm) 'fast))

    ;; Deshabilitar deshacer
    (buffer-disable-undo)

    (add-to-list 'ecb-non-semantic-methods-initial-expand 'fonlog-mode)
    (setq ecb-layout-name "FONETIC-log-layout")
    )

  (defun fonlog-config-keys ()
    "Configura los keybindings para el modo fonlog."
    (local-set-key (kbd "C-j") 'fonlog-parse-log-tx-result)
    )
#+END_SRC


Finally, lets define a mode to do all this when opening a =*.log= file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (define-derived-mode fonlog-mode auto-revert-tail-mode "fLog"
    "Modo mayor de visualización de logs de Fonetic."
    (fonlog-config-log-buffer)
    (fonlog-config-keys)
    (fonlog-imenu-config)
    (fonlog-font-lock-config)
    (font-lock-fontify-buffer)
    )
  (add-to-list 'auto-mode-alist '("\\.log\\'" . fonlog-mode))
#+END_SRC

** Fun
*** Music

I am currently using the [[https://github.com/dbrock/bongo][Bongo]] player with VLC in the backend (but it
supports many more out of the box).

Unfortunately, it does not work in Windows, so I use mplayer in that case,
which has a bug in bongo when dealing with online radios in .m3u

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bongo
    :defer t
    :bind ("C-c b" . bongo)
    :config (if (not (eq system-type 'windows-nt))
                (setq bongo-enabled-backends (quote (vlc)))
              (setq bongo-enabled-backends (quote (mplayer)))
              (bongo-backend-put 'mplayer 'file-name-transformers
                (cons (lambda (file-name)
                        (when (string-match "^http://.?\\.m3u$" file-name)
                                            (list file-name "-playlist")))
                      (bongo-backend-get 'mplayer 'file-name-transformers)))
              (bongo-backend-put 'mplayer 'file-name-transformers
                (cons (lambda (file-name)
                        (when (string-match "^http://.?\\.pls$" file-name)
                                            (list file-name "-playlist")))
                      (bongo-backend-get 'mplayer 'file-name-transformers)))))
#+END_SRC

*** Runic

I'm a total freak, and I love to write my secrets in [[https://en.wikipedia.org/wiki/Runes][runic]].
To deactivate the runic writing, use the keybinding =<f12>=

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun runic-write-off ()
    "Stop replacing character with runic ones"
    (interactive)
    (setq keyboard-translate-table nil)
    (global-unset-key (kbd "<f12>"))
    (message "Runic write mode disabled.")
  )

  (defun runic-write-on ()
    "Replace all characters with its runic equivalent"
    (interactive)
    (setq keyboard-translate-table
          (make-char-table 'keyboard-translate-table nil))

    (aset keyboard-translate-table 102 5792) ; F
    (aset keyboard-translate-table 97 5800)  ; A
    (aset keyboard-translate-table 114 5792) ; R
    (aset keyboard-translate-table 99 5810)  ; C, K, Q
    (aset keyboard-translate-table 107 5810)
    (aset keyboard-translate-table 113 5810)
    (aset keyboard-translate-table 103 5815) ; G
    (aset keyboard-translate-table 119 5817) ; W
    (aset keyboard-translate-table 104 5818) ; H
    (aset keyboard-translate-table 110 5822) ; N
    (aset keyboard-translate-table 105 5825) ; I
    (aset keyboard-translate-table 106 5827) ; J
    (aset keyboard-translate-table 112 5832) ; P
    (aset keyboard-translate-table 122 5833) ; Z
    (aset keyboard-translate-table 115 5835) ; S
    (aset keyboard-translate-table 116 5839) ; T
    (aset keyboard-translate-table 98 5842)  ; B
    (aset keyboard-translate-table 101 5846) ; E
    (aset keyboard-translate-table 109 5847) ; M
    (aset keyboard-translate-table 108 5850) ; L
    (aset keyboard-translate-table 111 5855) ; O
    (aset keyboard-translate-table 100 5854) ; D

    (global-set-key (kbd "<f12>") 'runic-write-off)

    (message "Runic write mode enabled. Press <f12> to exit.")
  )
#+END_SRC

** Workarounds
*** Clipboard

I want Emacs to share the clipboard with my SO.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clipmon
    :init (progn (setq clipmon-action 'kill-new clipmon-timeout nil clipmon-sound nil clipmon-cursor-color nil clipmon-suffix nil) (clipmon-mode)))
#+END_SRC

*** Windows OS

This section deals with everything that should be done in a Windows
enviroment to make this file usable.
We all hate Windows, being not only not free (as in freedom), but also
a crappy operating system. But sometimes I have to use it (mostly at
work), making this section necessary.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'windows-nt)
    ; FIX for keybindings
    (setq w32-pass-lwindow-to-system nil
          w32-lwindow-modifier 'super            ; Left Windows key
          w32-pass-rwindow-to-system nil
          w32-rwindow-modifier 'super            ; Right Windows key
          w32-pass-apps-to-system nil
          w32-apps-modifier 'hyper               ; Menu/App key
    ; FIX for aspell
          ispell-program-name "aspell"
          ispell-list-command "--list"
          ispell-personal-dictionary "~/.ispell"
    ; FIX for find
          find-program "C:\\cygwin64\\bin\\find.exe"
          gc-cons-threshold (* 100 1024 1024)   ; 100 mb
    ; FIX PATH
          exec-path (append '("C:\\cygwin64\\bin") exec-path))
    (setenv "PATH" (concat "C:\\cygwin64\\bin;" (getenv "PATH")))
    ; FIX for TRAMP
    (set-default 'tramp-auto-save-directory "~/AppData/Local/Temp")
    (set-default 'tramp-default-method "plink")
     ; Fix TLS
    (set-default 'gnutls-trustfiles (cons
                                     "C:/cygwin64/usr/ssl/certs/ca-bundle.trust.crt"
                                     "C:/cygwin64/usr/ssl/certs/ca-bundle.crt")))
#+END_SRC

** Things that I want to try
*** TODO Smartparens
*** TODO EMMS

#+BEGIN_SRC emacs-lisp :tangle yes

#+END_SRC

